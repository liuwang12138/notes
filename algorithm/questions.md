# Tree

1. 二叉树结构定义如下：

   ```java
   Class Node {
   	int value;
   	Node left;
   	Node right;
   	Node parent;
   }
   ```

   给你二叉树中的某个节点，返回该节点的后继节点

   > 后继节点：中序遍历中，节点的下一个节点

2. 请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有3条折痕，从上到下依次是下折痕、下折痕和上折痕

   给定一个输入参数N，代表纸条都是从下方向上方连续对折N次，请从上到下打印所有折痕的方向

   例如：N=1时，打印：down

   ​			N=2时，打印：down down up

> 树，中序

3. 给定一棵二叉树的头节点，判断这棵二叉树是不是平衡二叉树

   > 1. 左树平衡	2. 右树平衡	3. 自己平衡

4. 给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整棵二叉树的最大距离

   > X为头节点的树的最大距离
   >
   > 1. X无关：max(左树最大距离，右树最大距离)
   > 2. X有关：左树高度 + 右树高度

5. 给定一棵二叉树的头节点head，返回这棵二叉树中最大的二叉搜索子树的头节点

6. 派对的最大快乐值

   员工信息的定义如下：

   ```java
   class Employee {
   	public int happy;
   	public List<Employee> nexts;
   }
   ```

   公司的每个员工都符合Employee类的描述，整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。树的头节点是公司唯一的老板，除老板之外的每个员工都有唯一的直接上级，叶节点是没有任何下属的基层圆孔(nexts列表为空)，除基层员工外，每个员工都有一个或多个直接下级。

   这个公司现在要办party，你可以决定哪些员工来，哪些员工不来，规则：

   1. 如果某个员工来了，那么这个员工的所有直接下级都不能来；
   2. 派对的整体快乐值是所有到场员工快乐值的累加；
   3. 你的目标是让炮队的整体快乐值尽量最大；

   给定一棵多叉树的头节点boss，请返回排队的最大快乐值。