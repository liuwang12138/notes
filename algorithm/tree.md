```
/**
 *					 1
 *				  /    \
 *			     2		 3
 *		  	   /   \   /   \
 *		      4		5 6		7
 *
 * 递归序：1,2,4,4,4,2,5,5,5,2,1,3,6,6,6,3,7,7,7,3,1
 * 先序遍历：第一次递归序的时候打印：1,2,4,5,3,6,7
 * 中序遍历：第二次递归序的时候打印：4,2,5,1,6,3,7
 * 后序遍历：第三次递归序的时候打印：4,5,2,6,7,3,1
 **/
```

code：递归遍历二叉树，非递归遍历二叉树

非递归遍历二叉树：

> 准备一个栈
>
> 先序：头左右
>
> 1. 弹出即打印；2. 如有右，则入右；3. 如有左，则入左
>
> 后序：左右头，即头右左的后续
>
> 1. 弹出即放到s2里；2.如有左，则入左(s1)；3.如有右，则入右(s2)；4.弹s2里的元素，打印
>
> 中序：左头右
>
> 1. 整条左边界入栈；
> 2. 1无法继续了，弹出，来到弹出节点的右树上继续执行1

二叉树按层遍历

> queue
>
> Question：统计二叉树的最大宽度
>
> 1. Map			2. 不用Map

二叉树的序列化和反序列化

> 先序序列化，中序序列化，后序序列化，按层序列化

Question:

二叉树结构定义如下：

```java
Class Node {
	int value;
	Node left;
	Node right;
	Node parent;
}
```

给你二叉树中的某个节点，返回该节点的后继节点

> 后继节点：中序遍历中，节点的下一个节点

1. 暴力，找根节点，中序遍历，再找后继

2. ```
   if (节点有右孩子) {
   	//后继节点是右树的最左节点
   }
   if (节点没有右孩子) {
   	找父节点，如果我是父节点的右孩子，继续找父节点，什么时候子节点是父节点的左孩子，这个就是我的后继节点
   }
   Attention：
   整棵树的最右节点是没有后继的
   ```

二叉树的递归套路

> - 可以解决面试中绝大多数(>95%)的二叉树问题尤其是树形dp问题
> - 本质是利用递归遍历二叉树的便利性

1. 假设以X节点为头，假设可以向X左树和右树要任何信息
2. 在上一步的假设下，讨论以X为头节点的树，得到答案的可能性（最重要，常见的是分两种：和X有关，和X无关）
3. 列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4. 把左树信息和右树信息求全集，就是任何一颗子树都需要返回的信息S
5. 递归函数都返回S，每一棵子树都这么要求
6. 写代码，在代码中考虑如何把左树的信息和右树的信息整合出整棵树的信息