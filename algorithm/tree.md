```
/**
 *					 1
 *				  /    \
 *			     2		 3
 *		  	   /   \   /   \
 *		      4		5 6		7
 *
 * 递归序：1,2,4,4,4,2,5,5,5,2,1,3,6,6,6,3,7,7,7,3,1
 * 先序遍历：第一次递归序的时候打印：1,2,4,5,3,6,7
 * 中序遍历：第二次递归序的时候打印：4,2,5,1,6,3,7
 * 后序遍历：第三次递归序的时候打印：4,5,2,6,7,3,1
 **/
```

code：递归遍历二叉树，非递归遍历二叉树

非递归遍历二叉树：

> 准备一个栈
>
> 先序：头左右
>
> 1. 弹出即打印；2. 如有右，则入右；3. 如有左，则入左
>
> 后序：左右头，即头右左的后续
>
> 1. 弹出即放到s2里；2.如有左，则入左(s1)；3.如有右，则入右(s2)；4.弹s2里的元素，打印
>
> 中序：左头右
>
> 1. 整条左边界入栈；
> 2. 1无法继续了，弹出，来到弹出节点的右树上继续执行1

二叉树按层遍历

> queue
>
> Question：统计二叉树的最大宽度
>
> 1. Map			2. 不用Map

二叉树的序列化和反序列化

> 先序序列化，中序序列化，后序序列化，按层序列化